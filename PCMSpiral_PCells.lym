<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>'''
MIT License

Copyright (c) 2017 Stephen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'''

import pya
import math
import cmath
from pya import *

MODULE_NUMPY = True

dbu = 0.001
pi = cmath.pi
j = cmath.sqrt(-1)
sign = lambda x: math.copysign(1,x) #define the sign function
alpha = 1 #related to the spirals radius growth, can only guess and test so far

r = 16 #radius of the Sbend spiral
gap = 2 #gap between wgs
angle_stepsize = 0.0001 #0.00001 required for less than 1 nm error

# Create aliases for KLayout Python API methods:
Box = pya.Box
Point = pya.Point
Polygon = pya.Polygon
Text = pya.Text
Trans = pya.Trans
LayerInfo = pya.LayerInfo

###################################

#General Spiral Calculation Functions#
def frange(start,stop,step):
  #Used to define a float range, since python doesnt have a built in one
  x = start
  while x &lt;stop:
      yield x #returns value as generator, speeding up stuff
      x+=step
        
def angle_from_corrugation(r, length, grating_length):
    #Calculates the thetas at which the desired grating lengths are achieved. Outputs to an array    
    angle = 0
    current_length = 0
    x1=0
    y1=0
    current_total_length=0
    yield angle#yield acts as a return but gives a generator. This early yield is to return the 0 value
    
    while current_total_length &lt; length:
        while current_length &lt; grating_length: #if the length has no reached the grating length, continue
            deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha)    
            r_spiral = (r*sign(angle))+(gap*angle/pi)
            S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX
            x2 = S.real
            y2= S.imag
            
            angle += angle_stepsize #continue to increase step size
            current_length = math.sqrt((x2-x1)**2+(y2-y1)**2) #figureout of the distance betweenthe two points
        #print("currentLength"+str(current_length))
        #print("targetlength"+str(grating_length))
        yield angle
        x1=S.real
        y1=S.imag
        current_total_length +=current_length
        current_length=0
        
def spiral_gen(r,angle_array,w,cwidth,grating_length):
    #This generates the spirals coordinates from the given angle arrays.        
    for i in frange(0,len(angle_array)-1,1):
      angle=angle_array[i]
      angle_next=angle_array[i+1]
      
      #Calculate Slope to ensure the gratings are 90 degree with the center guide line, note that the final point will be ignored here and appeneded later
      deltaX = (r*sign(angle_next))*cmath.exp(-abs(angle_next)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #Second Point
      r_spiral = (r*sign(angle_next))+(gap*angle_next/pi)
      S = (r_spiral*cmath.exp(j*abs(angle_next)))-deltaX    
      x2 = S.real
      y2 = S.imag
      deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #First Point
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX 
      x1 = S.real
      y1 = S.imag 
      #Slope
      dx = (x2-x1)/grating_length
      dy = (y2-y1)/grating_length

      #Calculate the Coordinate for each grating and apply the slope modifer
      deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #Outer, C1
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX    
      xcoor_Winc1 = S.real+dy*(w+cwidth)
      ycoor_Winc1 = S.imag-dx*(w+cwidth)
      
      #Outer C2
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc2 = S.real+dy*(w-cwidth)
      ycoor_Winc2 = S.imag-dx*(w-cwidth)
      #Inner, C1
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc3 = S.real-dy*(w-cwidth)
      ycoor_Winc3 = S.imag+dx*(w-cwidth)
      #Inner C2
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc4 = S.real-dy*(w+cwidth)
      ycoor_Winc4 = S.imag+dx*(w+cwidth)
      yield xcoor_Winc1,ycoor_Winc1,xcoor_Winc2,ycoor_Winc2,xcoor_Winc3,ycoor_Winc3,xcoor_Winc4,ycoor_Winc4
    
    #for the final point, uses the final angle and appends it as the original equation would've (refer to legacy version)
    #this is because the forced perpendicular would cause some polygonal issues that isnt worth the fix
    #plus at the outer radius, the final grating is pretty much perpendicular anyways.
    angle = angle_array[-1]  
    deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha) #r, not r_inc here because then it will all end at 0,0     
    #Outer, C1
    r_spiral = ((r+w+cwidth)*sign(angle))+(gap*angle/pi)
    S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX    
    xcoor_Winc1 = S.real
    ycoor_Winc1 = S.imag    
    #Outer C2
    r_spiral = ((r+w-cwidth)*sign(angle))+(gap*angle/pi)
    S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
    xcoor_Winc2 = S.real
    ycoor_Winc2 = S.imag
    #Inner, C1
    r_spiral = ((r-w+cwidth)*sign(angle))+(gap*angle/pi)
    S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
    xcoor_Winc3 = S.real
    ycoor_Winc3 = S.imag
    #Inner C2
    r_spiral = ((r-w-cwidth)*sign(angle))+(gap*angle/pi)
    S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
    xcoor_Winc4 = S.real
    ycoor_Winc4 = S.imag
    yield xcoor_Winc1,ycoor_Winc1,xcoor_Winc2,ycoor_Winc2,xcoor_Winc3,ycoor_Winc3,xcoor_Winc4,ycoor_Winc4
        
''' LEGACY, For reference
def spiral_gen(r,angle_array,w,cwidth):
    #This generates the spirals coordinates from the given angle arrays.

    #The radius of the individual walls, basically draws 2 lines for each wall of the waveguide and appends hte points
    r_Winc_Cinc = r+w+cwidth
    r_Winc_Cdec = r+w-cwidth
    r_Wdec_Cinc = r-w +cwidth
    r_Wdec_Cdec = r-w -cwidth
        
    for angle in angle_array: #finds the points corresponding to the grating lengths we want based on center line
        deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha) #r, not r_inc here because then it will all end at 0,0
        #deltaY = (r*sign(angle))*cmath.exp(j*abs(angle)/alpha)  
        
        #Outer, C1
        r_spiral = (r_Winc_Cinc*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX    
        xcoor_Winc1 = S.real
        ycoor_Winc1 = S.imag
        #Outer C2
        r_spiral = (r_Winc_Cdec*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
        xcoor_Winc2 = S.real
        ycoor_Winc2 = S.imag
        
        #Inner, C1
        r_spiral = (r_Wdec_Cinc*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
        xcoor_Winc3 = S.real
        ycoor_Winc3 = S.imag
        #Inner C2
        r_spiral = (r_Wdec_Cdec*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
        xcoor_Winc4 = S.real
        ycoor_Winc4 = S.imag
        
        yield xcoor_Winc1,ycoor_Winc1,xcoor_Winc2,ycoor_Winc2,xcoor_Winc3,ycoor_Winc3,xcoor_Winc4,ycoor_Winc4            
'''   
    
def sort_coord(bool_order,xinc,yinc,xdec,ydec):
    #this organizes the two sets of coordinates for each wall into an order to create gratings
    #can pass bool_order to decide which gets drawn first
    x_array=[]
    y_array=[]
    
    for i in range(len(xinc)):
        if bool_order == True:
            x_array.append(xdec[i])
            x_array.append(xinc[i])
            y_array.append(ydec[i])
            y_array.append(yinc[i])
            bool_order = not bool_order
        else:
            x_array.append(xinc[i])
            x_array.append(xdec[i])
            y_array.append(yinc[i])
            y_array.append(ydec[i])
            bool_order = not bool_order
    return x_array,y_array            
       
def finish_spiral(r,finalangle,w):
    #This finishes the spiral to the 0 or 180 position with a uniform waveguide, also makes it easier to match via pins
    #The radius of the individual walls, basically draws 2 lines for each wall of the waveguide and appends hte points
    r_Winc = r+w
    r_Wdec = r-w
    
    x_inc=[]
    y_inc=[]
    x_dec=[]
    y_dec=[]
    
    nextpie = math.ceil(finalangle/ (pi)) * pi        
    for angle in frange(finalangle,nextpie,0.01):
        deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha)
        
        r_spiral = (r_Winc*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX  
        x_inc.append(S.real)
        y_inc.append(S.imag)
        
        r_spiral = (r_Wdec*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX  
        x_dec.append(S.real)
        y_dec.append(S.imag)
        
    #appends the final coordinate at y=0
    deltaX = (r*sign(nextpie))*cmath.exp(-abs(nextpie)/alpha)
    r_spiral = (r_Winc*sign(nextpie))+(gap*nextpie/pi)
    S = (r_spiral*cmath.exp(j*abs(nextpie)))-deltaX 
    x_inc.append(S.real)
    y_inc.append(S.imag)
    
    deltaX = (r*sign(nextpie))*cmath.exp(-abs(nextpie)/alpha)
    r_spiral = (r_Wdec*sign(nextpie))+(gap*nextpie/pi)
    S = (r_spiral*cmath.exp(j*abs(nextpie)))-deltaX 
    x_dec.append(S.real)
    y_dec.append(S.imag)

    deltaX = (r*sign(nextpie))*cmath.exp(-abs(nextpie)/alpha)
    r_spiral = (r*sign(nextpie))+(gap*nextpie/pi)
    S = (r_spiral*cmath.exp(j*abs(nextpie)))-deltaX 
    endx = S.real
    endy = S.imag
    
    return x_inc,y_inc,x_dec,y_dec,endx,endy
###########################

class PCMSpiralBraggGrating(pya.PCellDeclarationHelper):

  def __init__(self):

    # Important: initialize the super class
    super(PCMSpiralBraggGrating, self).__init__()

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = LayerInfo(1, 0))
    self.param("w", self.TypeDouble, "Waveguide Width [nm]", default = 400)
    self.param("DeviceLength", self.TypeDouble, "Device Path Length [mm]", default = 0.5)
    self.param("Cwidth", self.TypeDouble, "Corrugation Width [nm]", default = 80)
    self.param("period", self.TypeDouble, "period [nm]", default = 420 ) 
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = LayerInfo(69, 0))
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = LayerInfo(68, 0))
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "SpiralBraggGrating"

  def can_create_from_shape_impl(self):
    return False   
  
  def produce_impl(self):
    # This is the main part of the implementation: create the layout
    
    # fetch the parameters
    #self.w = 400
    #self.Length = 0.5
    #self.Cwidth = 80
    #self.pitch = 420
    #self.Chirp_Rate = 0
    #self.n = 1800
    
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TextLayerN = ly.layer(self.textl)
    
    w = self.w*10**-3/2.0 #drawing from center line, only have to add half
    length = self.DeviceLength*1000/2.0#only drawing half and then copying
    cwidth = self.Cwidth*10**-3/2.0 #same reason as width
    grating_length = self.period/2.0*10**-3
     
    #Step1 Find the Angles of each grating#######    
    angle_array=[]
    for theta in angle_from_corrugation(r,length,grating_length):
        angle_array.append(theta)
    ####################
    
    #####################
    #Step2 Find the Coordinates of the gratings via the angles
    #Wall1 of the Left    
    left_x_inc = []
    left_y_inc = []
    left_x_dec = []
    left_y_dec = []
    #Wall2 of the Left
    left2_x_inc = []
    left2_y_inc = []
    left2_x_dec = []
    left2_y_dec = []
    
    #Calculate the Spiral Coordinates
    for coord in spiral_gen(r,angle_array,w,cwidth,grating_length):
        left_x_inc.append(coord[0])
        left_y_inc.append(coord[1])
        left_x_dec.append(coord[2])
        left_y_dec.append(coord[3])
        
        left2_x_inc.append(coord[4])
        left2_y_inc.append(coord[5])
        left2_x_dec.append(coord[6])
        left2_y_dec.append(coord[7])
    
    #Flip coords for right side coords
    right_x_inc = [i*-1 for i in left_x_inc]
    right_y_inc = [i*-1 for i in left_y_inc]
    right_x_dec = [i*-1 for i in left_x_dec]
    right_y_dec = [i*-1 for i in left_y_dec]
    
    right2_x_inc = [i*-1 for i in left2_x_inc]
    right2_y_inc = [i*-1 for i in left2_y_inc]
    right2_x_dec = [i*-1 for i in left2_x_dec]
    right2_y_dec = [i*-1 for i in left2_y_dec]
    #Obtain a sorted list of the coordinates of one wall.
    #repeat for the rest
    result = sort_coord(True,left_x_inc,left_y_inc,left_x_dec,left_y_dec)
    left1x = result[0]
    left1y = result[1]
    result = sort_coord(False,left2_x_inc,left2_y_inc,left2_x_dec,left2_y_dec)
    left2x = result[0]
    left2y = result[1]
    
    result = sort_coord(False,right_x_inc,right_y_inc,right_x_dec,right_y_dec)
    right1x = result[0]
    right1y = result[1]
    #Delete the first two points as they over lap
    del right1x[0]#calls the same index here because once you remove 0, 1 becomes 0, and so on and so forth
    del right1x[0]
    del right1y[0]
    del right1y[0]
    
    result = sort_coord(True,right2_x_inc,right2_y_inc,right2_x_dec,right2_y_dec)
    right2x = result[0]
    right2y = result[1]
    del right2x[0]
    del right2x[0]
    del right2y[0]
    del right2y[0]
    
    #UNIFORM SECTION
    del left1x[-1]
    del left1y[-1]
    del left2x[-1]
    del left2y[-1]
    
    del right1x[-1]
    del right1y[-1]
    del right2x[-1]
    del right2y[-1]
     
    result = finish_spiral(r,angle_array[-1],w)
    left1x.extend(result[0])
    left1y.extend(result[1])
    left2x.extend(result[2])
    left2y.extend(result[3])
    
    right1x.extend(i*-1 for i in result[0])
    right1y.extend(i*-1 for i in result[1])
    right2x.extend(i*-1 for i in result[2])
    right2y.extend(i*-1 for i in result[3])
    #########################################
    
    #Step3 Organize all the points into a single matrix to be drawn in klayout.
    spiral_x = []
    spiral_y = []
    
    spiral_x.extend(reversed(left1x))
    spiral_x.extend(right2x)
    spiral_x.extend(reversed(right1x))
    spiral_x.extend(left2x)
    
    spiral_y.extend(reversed(left1y))
    spiral_y.extend(right2y)
    spiral_y.extend(reversed(right1y))
    spiral_y.extend(left2y)
    
    #makes Dpoints from the coordinates
    dpts=[pya.DPoint(spiral_x[i], spiral_y[i]) for i in range(len(spiral_x))]
    dpolygon = DPolygon(dpts)    
    #dmult_pts = mult_pts(dpts,1)
        
    #dpoint polygon solution thanks to Jaspreet#
    element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    shapes(LayerSiN).insert(element)
    #shapes(LayerSiN).insert(Polygon.from_dpoly(dpolygon))
        
    # Create the pins, as short paths:
    pin_length = 200 # database units, = 0.2 microns
    LendX = result[4]
    LendY = result[5]
    RendX = -result[4]
    RendY = -result[5]
    
    pin = pya.Path([Point(RendX/dbu, RendY/dbu-pin_length/2), Point(RendX/dbu, RendY/dbu+pin_length/2)], w/dbu*2)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(RendX/dbu, RendY/dbu)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = pya.Path([Point(LendX/dbu, LendY/dbu-pin_length/2), Point(LendX/dbu, LendY/dbu+pin_length/2)], w/dbu*2)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(LendX/dbu, LendY/dbu)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
      
    # Create the device recognition layer
    dev = Box(LendX, 0, RendX, RendY*2 )
    shapes(LayerDevRecN).insert(dev)
    
    
    # Add a polygon text description
    #if self.textpolygon:
      #layout_pgtext(self.cell, self.textl, -5, 0, "PCM Spiral width:%.2f period:%.2f cwidth:%.2f L:%.2f]" % ( self.w, self.pitch,self.Cwidth,self.DeviceLength), 1)
   
    print("Done drawing the layout for - PCM Spiral")
    ##extra functions used for drawing##
    

class SiEPIC(pya.Library):
  """
  The library where we will put the PCell into 
  """

  def __init__(self):

    print("Initializing PCM Spiral PCells library.")
  
    # Set the description
    self.description = "EBeam"
    
    # Create the PCell declarations
    self.layout().register_pcell("PCMSpiral_BraggGrating", PCMSpiralBraggGrating())


    # Register us with the name "".
    # If a library with that name already existed, it will be replaced then.
    self.register("PCMSpiral")
 
# Instantiate and register the library
SiEPIC()
</text>
</klayout-macro>
